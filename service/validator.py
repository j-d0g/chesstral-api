import json
import re

import chess


def validate_response(output: str, board: chess.Board):
    """
    Validates the move generated by the LLM.
    :param output: Output string from the LLM.
    :param board: Current chess board state
    :return: Tuple containing the response JSON (move and thoughts) and an error message (if any)
    """
    legal_moves: list[chess.Move] = list(board.legal_moves)
    cleaned_json: str = clean_json(output)

    # Validate JSON
    try:
        response_json: dict = json.loads(cleaned_json)
        san_move: str = response_json['move']
    except (json.JSONDecodeError, KeyError, TypeError) as e:
        return handle_json_error(e, cleaned_json)
    # Validate Move
    try:
        san_move = san_move[san_move.find('.') + 1:]
        san_move = san_move.replace(' ', '')
        chess_move: chess.Move = board.parse_san(san_move)
        if chess_move in legal_moves:
            response_json['move'] = board.san(chess_move)
            return response_json, None
        else:
            raise chess.IllegalMoveError
    except Exception as e:
        return handle_move_error(e, san_move, board)


def clean_json(text: str) -> str:
    """
    Cleans the text into a more readable JSON string, removing excess characters that interfere with parsing json/move.
    :param text: Input text string
    :return: Extracted JSON string, or the original text if no JSON is found
    """
    text = re.sub(r'\n', r'', text)
    start = text.find('{')
    end = text.rfind('}')
    return text[start:end + 1] if start != -1 and end != -1 else text


def handle_json_error(error: Exception, json_str: str):
    """
    Returns error-specific prompts to regenerate response for JSON errors.
    :param error: The exception object representing the JSON error
    :param json_str: Response JSON string
    :return: Tuple containing None and the corresponding error message
    """
    if isinstance(error, json.JSONDecodeError):
        return None, f'Invalid JSON response: """{json_str}""" is not a valid JSON object. Regenerate your response, providing your thoughts and move in the correct JSON format: {{"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}}.'
    elif isinstance(error, (KeyError, TypeError)):
        return None, f'Invalid JSON response: """{json_str}""" is missing the "move" key. Regenerate your response, providing the move key in the correct JSON format: {{"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}}.'


def handle_move_error(error, move, board):
    """
    Returns error-specific prompts to regenerate response for chess-move errors.
    :param error: The exception object representing the move error
    :param move: The move that caused the error
    :param board: Current chess board state
    :return: Tuple containing None and the corresponding error message
    """

    legal_moves: list[chess.Move] = list(board.legal_moves)
    legal_moves_san: list[str] = [board.san(chess_move) for chess_move in legal_moves]
    legal_moves_uci: list[str] = [chess_move.uci() for chess_move in legal_moves]

    if isinstance(error, chess.IllegalMoveError):
        return None, f"Illegal move: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Here are the current legal moves in SAN you can make: '''{', '.join(legal_moves_san)}'''."
    elif isinstance(error, chess.AmbiguousMoveError):
        return None, f"Ambiguous move: '{move}'. Regenerate your response to my last prompt, but this time using either long-SAN by specifying the file of the origin piece (i.e Nhg8 instead of Ng8), or UCI format (i.e f6g8). Legal UCI moves: '''{', '.join(legal_moves_uci)}'''."
    elif isinstance(error, chess.InvalidMoveError):
        try:
            print('The move is getting away here!')
            print(move)
            # If move was an invalid SAN format, attempt to clean and convert from UCI format
            uci_move: str = re.sub(r'[-+#nqrkNQRBK]', '', move)
            uci_move: chess.Move = chess.Move.from_uci(uci_move)
            if uci_move in legal_moves:
                return {'move': board.san(uci_move), 'thoughts': 'higgidy diggidy'}, None
            else:
                return None, f"Illegal move: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."
        except (ValueError, chess.InvalidMoveError):
            return None, f"Invalid move format: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move using either SAN-format or UCI-format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."
    else:
        return None, f'Invalid move: {move}. Regenerate your response but choose a valid SAN move: {legal_moves_san}.'
