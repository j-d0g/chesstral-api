import json
import re

import chess


def validate_json(output: str):
    """
    Validates the move generated by the LLM.
    :param output: Output string from the LLM.
    :param board: Current chess board state
    :return: Tuple containing the response JSON (move and thoughts) and an error message (if any)
    """
    valid_json_str: str = extract_json(output)
    try:
        response_json: dict = json.loads(valid_json_str)
        if 'move' not in response_json:
            raise KeyError
    except (json.JSONDecodeError, KeyError) as e:
        return regenerate_json(e, valid_json_str)
    return response_json


def validate_move(board, response_json):
    print(response_json)
    move = response_json['move']
    try:
        response_json['move'] = extract_move(move, board)
    except Exception as e:
        return regenerate_move(e, move, board)
    return response_json


def extract_move(move: str, board: chess.Board):
    """
    Parses the move string into a chess.Move object.
    :param move: The move string to parse
    :param board: Current chess board state
    :return: The parsed chess.Move object
    """
    try:
        san_move: str = move[move.rfind('.') + 1:]
        print(san_move)
        san_move: str = san_move.replace(' ', '')
        chess_move: chess.Move = board.parse_san(san_move)
    except (chess.IllegalMoveError, chess.InvalidMoveError) as san_error:
        try:
            uci_move: str = re.sub(r'[-+#nqrkNQRBK]', '', move)
            chess_move: chess.Move = chess.Move.from_uci(uci_move)
            if chess_move not in board.legal_moves:
                raise chess.IllegalMoveError
        except (chess.IllegalMoveError, chess.InvalidMoveError) as uci_error:
            raise san_error from uci_error

    return board.san(chess_move)


def extract_json(text: str) -> str:
    """
    Cleans the text into a more readable JSON string, removing excess characters that interfere with parsing json/move.
    :param text: Input text string
    :return: Extracted JSON string, or the original text if no JSON is found
    """
    text = re.sub(r'\n', r'', text)
    start = text.find('{')
    end = text.rfind('}')
    return text[start:end + 1] if start != -1 and end != -1 else text


def regenerate_json(error: Exception, json_str: str):
    """
    Returns error-specific prompts to regenerate response for JSON errors.
    :param error: The exception object representing the JSON error
    :param json_str: Response JSON string
    :return: Tuple containing None and the corresponding error message
    """
    schema_move = {"move": "Your move in SAN notation"}
    schema = {"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}
    reprompt_message = {}

    if isinstance(error, json.JSONDecodeError):
        reprompt_message[
            'reprompt'] = f'Invalid JSON response: """{json_str}""" is not a valid JSON object. Regenerate your response, providing your thoughts and move in the correct JSON format: {schema}.'
    elif isinstance(error, KeyError):
        reprompt_message[
            'reprompt'] = f'Invalid JSON response: """{json_str}""" is missing the "move" key. Regenerate your response, providing the "move" key in the correct JSON format: {schema}.'
    else:
        raise error
    return reprompt_message


def regenerate_move(error, move, board):
    """
    Returns error-specific prompts to regenerate response for chess-move errors.
    :param error: The exception object representing the move error
    :param move: The move that caused the error
    :param board: Current chess board state
    :return: Tuple containing None and the corresponding error message
    """

    legal_moves: list[chess.Move] = list(board.legal_moves)
    legal_moves_san: list[str] = [board.san(chess_move) for chess_move in legal_moves]
    legal_moves_uci: list[str] = [chess_move.uci() for chess_move in legal_moves]

    reprompt_message = {}

    if isinstance(error, chess.IllegalMoveError):
        reprompt_message[
            'reprompt'] = f"Illegal move: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Here are the current legal moves in SAN you can make: '''{', '.join(legal_moves_san)}'''."
    elif isinstance(error, chess.AmbiguousMoveError):
        reprompt_message[
            'reprompt'] = f"Ambiguous move: '{move}'. Regenerate your response to my last prompt, but this time using either long-SAN by specifying the file of the origin piece (i.e Nhg8 instead of Ng8), or UCI format (i.e f6g8). Legal UCI moves: '''{', '.join(legal_moves_uci)}'''."
    elif isinstance(error, chess.InvalidMoveError):
        reprompt_message[
            'reprompt'] = f"Invalid move format: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move using either SAN-format or UCI-format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."
    else:
        raise error
    return reprompt_message
