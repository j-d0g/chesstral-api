import json
import re
import chess
from pprint import pprint
from service.chess_util.prompt_generator import system_chess_prompt, user_chess_prompt


def get_llm_move(fen: str, llm, model_name: str = None, max_retries: int = 15):
    """
    Generates a chess move using the Mistral API.
    :param fen: FEN string representing the current board state
    :param llm: Language model instance
    :param model_name: Name of the language model to use (optional)
    :param max_retries: Maximum number of retries before giving up (default: 15)
    :return: JSON object containing the move and thoughts, or an error message
    """
    board = chess.Board(fen)
    llm.add_message(llm.prompt_template("system", system_chess_prompt()))
    llm.add_message(llm.prompt_template("user", user_chess_prompt(board)))

    print('****** INPUT ******\n ')
    pprint(llm.get_messages())

    for retry in range(max_retries):
        output: str = llm.generate_text(model_name=model_name)

        print('****** RAW OUTPUT ********\n ')
        pprint(output)

        response_json, error_message = validate_response(output, board)
        llm.add_message(llm.prompt_template("assistant", output))

        if response_json:
            return response_json

        print('****** ERROR MESSAGE ******\n ')
        pprint(error_message)

        if retry % 5 == 0:
            llm.reset_messages()

        regenerate_message = f"{error_message}. Previous prompt: '''{user_chess_prompt(board)}'''"
        llm.add_message(llm.prompt_template("user", regenerate_message))

        print('****** CONVERSATION HISTORY ******\n ')
        [pprint(message) for message in llm.get_messages()]

    return {'error': 'Exceeded maximum retries'}


def validate_response(output: str, board: chess.Board):
    """
    Validates the move generated by the Mistral API.
    :param output: Output string from the Mistral API
    :param board: Current chess board state
    :return: Tuple containing the response JSON (move and thoughts) and an error message (if any)
    """
    legal_moves: list[chess.Move] = list(board.legal_moves)
    extracted_json_str: str = extract_json(output)

    print("****** EXTRACTED JSON STRING ******\n")
    pprint(extracted_json_str)

    # Handle JSON Validation
    try:
        response_json: dict = json.loads(extracted_json_str)
        san_move: str = response_json['move']
    except (json.JSONDecodeError, KeyError, TypeError) as e:
        return handle_json_error(e, extracted_json_str)

    print("****** RESPONSE JSON ******\n")
    pprint(response_json)

    # Handle Move Validation
    try:
        chess_move: chess.Move = board.parse_san(san_move)
        if chess_move in legal_moves:
            return response_json, None
    except (chess.AmbiguousMoveError, chess.InvalidMoveError, chess.IllegalMoveError) as e:
        return handle_move_error(e, san_move, board)


def extract_json(text: str) -> str:
    """
    Extracts a JSON object from a given text string.
    :param text: Input text string
    :return: Extracted JSON string, or the original text if no JSON is found
    """
    text = re.sub(r'\n', r'', text)
    start = text.find('{')
    end = text.rfind('}')
    return text[start:end + 1] if start != -1 and end != -1 else text


def handle_json_error(error, extracted_json_str):
    """
    Handles different types of JSON errors and returns appropriate error messages.
    :param error: The exception object representing the JSON error
    :param extracted_json_str: Extracted JSON string from the API response
    :return: Tuple containing None and the corresponding error message
    """
    if isinstance(error, json.JSONDecodeError):
        return None, f'Invalid JSON response: """{extracted_json_str}""" is not a valid JSON object. Regenerate your response, providing your thoughts and move in the correct JSON format: {{"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}}.'
    elif isinstance(error, (KeyError, TypeError)):
        return None, f'Invalid JSON response: """{extracted_json_str}""" is missing the "move" key. Regenerate your response, providing the move key in the correct JSON format: {{"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}}.'


def handle_move_error(error, move, board):
    """
    Handles different types of move errors and returns appropriate error messages.
    :param error: The exception object representing the move error
    :param move: The move that caused the error
    :param legal_moves_san: List of legal moves in SAN format
    :param legal_moves_uci: List of legal moves in UCI format
    :param board: Current chess board state
    :return: Tuple containing None and the corresponding error message
    """
    legal_moves: list[chess.Move] = list(board.legal_moves)
    legal_moves_san: list[str] = [board.san(chess_move) for chess_move in legal_moves]
    legal_moves_uci: list[str] = [chess_move.uci() for chess_move in legal_moves]

    if isinstance(error, chess.IllegalMoveError):
        return None, f"Illegal move: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Here are the current legal moves in SAN you can make: '''{', '.join(legal_moves_san)}'''."
    elif isinstance(error, chess.AmbiguousMoveError):
        return None, f"Ambiguous move: '{move}'. Regenerate your response to my last prompt, but this time using either long-SAN by specifying the file of the origin piece (i.e Nhg8 instead of Ng8), or UCI format (i.e f6g8). Legal UCI moves: '''{', '.join(legal_moves_uci)}'''."
    elif isinstance(error, chess.InvalidMoveError):
        try:
            uci_move: str = re.sub(r'[-+#nqrkNQRBK\s]', '', move)
            uci_move: chess.Move = chess.Move.from_uci(uci_move)
            if uci_move in legal_moves:
                return {'move': board.san(uci_move)}, None
            else:
                return None, f"Illegal move: '{uci_move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."
        except (ValueError, chess.InvalidMoveError):
            return None, f"Invalid move format: '{move}'. Regenerate your response to my last prompt, but this time provide a single, legal move using either SAN-format or UCI-format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."