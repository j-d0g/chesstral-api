import json
import re
import chess
from pprint import pprint
from chess_service.prompt_generator import role_to_str, generate_prompt


def system_chess_prompt() -> str:
    """ Returns a system template for Mistral chat."""

    system_msg = ('You are an auto-regressive language model that is brilliant at reasoning and playing chess. '
                  'Your goal is to use your reasoning and chess skills to produce the best chess move given a board position. '
                  'Since you are autoregressive, each token you produce is another opportunity to use computation, therefore '
                  'you always spend a few sentences discussing your thoughts step-by-step before deducing the best move by using '
                  'your knowledge of chess rules, common tactics, and the current board-state. Your thoughts should be brief '
                  'yet pragmatically structured, and you must always return a legal and valid move in the correct format.'
                  )

    # system_msg = ()

    return system_msg


def user_chess_prompt(board: chess.Board) -> str:
    """ Returns a content template for Mistral chat."""

    role = role_to_str(board)
    board_str = generate_prompt(board, pgn=False, fen=True, positions=True, legalmoves=True, threats=True)
    json_str = 'Provide your thoughts and move in the correct JSON format: {"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}.'
    prompt = " ".join([role, board_str, json_str])

    return prompt


def get_llm_move(fen: str, llm, model_name: str = None):
    """
    Generates a move using Mistral API.
    :param fen:
    :param llm:
    :param model_name:
    :return:
    """

    board = chess.Board(fen)
    sys = llm.prompt_template("system", system_chess_prompt())
    prompt = llm.prompt_template("user", user_chess_prompt(board))

    llm.add_message(sys)
    llm.add_message(prompt)

    print('****** INPUT ******\n ')
    pprint(llm.get_messages())

    retries, MAX_RETRIES = 0, 15
    while retries < MAX_RETRIES:
        output: str = llm.generate_text(model_name=model_name)

        print('****** RAW OUTPUT ********\n ')
        pprint(output)

        response_json, error_message = validate_move(output, board)
        llm.add_message(llm.prompt_template("assistant", output))

        if response_json:
            return response_json
        else:
            if retries % 5 == 0:
                llm.reset_messages()

            print('****** ERROR MESSAGE ******\n ')
            pprint(error_message)

            regenerate_message = f"{error_message}. Previous prompt: '''{prompt}'''"

            llm.add_message(llm.prompt_template("user", regenerate_message))
            print('****** CONVERSATION HISTORY ******\n ')
            [pprint(message) for message in llm.get_messages()]
            retries += 1

    return {'error': 'Exceeded maximum retries'}


def validate_move(output: str, board: chess.Board):
    """
    Validates the move generated by Mistral API.
    :param output:
    :param board:
    :return: response_json: move and thoughts, error_message: error message if move is invalid
    """

    def extract_json(text):
        # Replaces newline characters with escaped newline characters
        text = re.sub(r'\n', r'', text)
        # Extracts JSON, discards extra text
        start = text.find('{')
        end = text.rfind('}')
        """handles case if {} not found"""
        if start == -1 or end == -1:
            return text
        else:
            return text[start:end + 1]

    # Move legality for validation
    legal_moves: list[chess.Move] = list(board.legal_moves)
    legal_moves_san: list[str] = [board.san(chess_move) for chess_move in legal_moves]
    legal_moves_uci: list[str] = [chess_move.uci() for chess_move in legal_moves]

    # Extract JSON object from Mistral API response
    extracted_json_str: str = extract_json(output)

    print("****** EXTRACTED JSON STRING ******\n")
    pprint(extracted_json_str)

    try:
        response_json: dict = json.loads(extracted_json_str)
        san_move: str = response_json['move']
    except json.JSONDecodeError:
        return None, 'Invalid JSON response: your last response is valid JSON object. Regenerate your response, providing your thoughts and move in the correct JSON format: {"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}.'
    except (KeyError, TypeError):
        return None, 'Invalid JSON response: the "move" key could not be found in the JSON you returned. Regenerate your response, providing the move key in the correct JSON format: {"thoughts": "Your reasoning-steps here", "move": "Your move in SAN notation"}.'
    print("****** RESPONSE JSON ******\n")
    pprint(response_json)
    # At the moment, there's a bug here where UCI-formatted moves entered into parse_san() lead directly to the exception-handling block, skipping UCI from ever being parsed.
    try:
        # Extract move from JSON response in SAN format
        san_move: str = response_json['move']
        chess_move: chess.Move = board.parse_san(san_move)
        if chess_move in legal_moves:
            return response_json, None
    except chess.IllegalMoveError:
        return None, f"Illegal move: '{san_move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Here are the current legal moves in SAN you can make: '''{', '.join(legal_moves_san)}'''."
    except chess.AmbiguousMoveError:
        return None, f"Ambiguous move: '{san_move}'. Regenerate your response to my last prompt, but this time using either long-SAN by specifying the file of the origin piece (i.e Nhg8 instead of Ng8), or UCI format (i.e f6g8). Legal UCI moves: '''{', '.join(legal_moves_uci)}'''."
    except chess.InvalidMoveError:
        # If move is invalid SAN format, attempt to convert from UCI format
        try:
            uci_move: str = re.sub(r'[-+#nqrkNQRBK\s]', '', san_move)
            uci_move: chess.Move = chess.Move.from_uci(uci_move)

        except chess.IllegalMoveError:
            return None, f"Illegal move: '{uci_move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Here are the current legal moves in SAN you can make: '''{', '.join(legal_moves_san)}'''."
        except (ValueError, chess.InvalidMoveError):
            return None, f"Invalid move format: '{san_move}'. Regenerate your response to my last prompt, but this time provide a single, legal move using either SAN-format or UCI-format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."

        if uci_move in legal_moves:
            response_json['move'] = board.san(uci_move)
            return response_json, None

        # If uci_move isn't in legal_moves either, return an error message
        return None, f"Illegal move: '{uci_move}'. Regenerate your response to my last prompt, but this time provide a single, legal move in SAN format. Legal SAN moves: '''{', '.join(legal_moves_san)}'''."