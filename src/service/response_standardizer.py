"""
Response standardizer for ChessGPT API
Ensures all engines return consistent response format regardless of internal implementation
"""

import chess
from typing import Dict, Any, Optional
import uuid
from datetime import datetime


def standardize_move_response(
    raw_response: Dict[str, Any], 
    engine_name: str, 
    fen: str,
    success: bool = True,
    error_message: Optional[str] = None
) -> Dict[str, Any]:
    """
    Standardize move response from any engine to a consistent format
    
    Args:
        raw_response: The raw response from the engine
        engine_name: Name of the engine that generated the response
        fen: Current board position in FEN notation
        success: Whether the move generation was successful
        error_message: Error message if success=False
        
    Returns:
        Standardized response format
    """
    
    # Extract move and thoughts from various response formats
    move = extract_move_from_response(raw_response)
    thoughts = extract_thoughts_from_response(raw_response)
    move_uuid = extract_uuid_from_response(raw_response)
    
    # Validate and normalize the move
    normalized_move, move_valid = normalize_move_notation(move, fen)
    
    # Generate confidence score based on engine and response quality
    confidence = calculate_confidence(engine_name, move_valid, raw_response)
    
    # Create standardized response
    standardized_response = {
        "success": success and move_valid,
        "move": normalized_move,
        "move_san": convert_to_san(normalized_move, fen) if move_valid else None,
        "move_uci": convert_to_uci(normalized_move, fen) if move_valid else None,
        "thoughts": thoughts,
        "confidence": confidence,
        "engine": engine_name,
        "timestamp": datetime.utcnow().isoformat() + "Z",
        "uuid": move_uuid or str(uuid.uuid4()),
        "board_fen": fen,
        "error": error_message if not success else None,
        "raw_response": raw_response if not success else None  # Include raw response for debugging failures
    }
    
    return standardized_response


def extract_move_from_response(response: Dict[str, Any]) -> Optional[str]:
    """Extract move from various response formats"""
    if not response:
        return None
        
    # Direct move field
    if "move" in response:
        return response["move"]
    
    # Nested in prompt.completion structure (LLM responses)
    if "prompt" in response and "completion" in response["prompt"]:
        return response["prompt"]["completion"].get("move")
    
    # Other possible structures
    if "completion" in response:
        return response["completion"].get("move")
        
    return None


def extract_thoughts_from_response(response: Dict[str, Any]) -> str:
    """Extract thoughts/reasoning from various response formats"""
    if not response:
        return ""
        
    # Direct thoughts field
    if "thoughts" in response:
        return response["thoughts"]
    
    # Nested in prompt.completion structure
    if "prompt" in response and "completion" in response["prompt"]:
        return response["prompt"]["completion"].get("thoughts", "")
    
    # Other possible structures
    if "completion" in response:
        return response["completion"].get("thoughts", "")
        
    # Model-specific field
    if "model" in response:
        return f"Generated by {response['model']}"
        
    return ""


def extract_uuid_from_response(response: Dict[str, Any]) -> Optional[str]:
    """Extract UUID from response if available"""
    if not response:
        return None
        
    return response.get("uuid")


def normalize_move_notation(move: str, fen: str) -> tuple[str, bool]:
    """
    Normalize move notation and validate it's legal
    
    Returns:
        (normalized_move, is_valid)
    """
    if not move or move in ["N/A", "", "None", "resign", "#"]:
        return move or "", False
    
    try:
        board = chess.Board(fen)
        
        # Try to parse as SAN first (e4, Nf3, etc.)
        try:
            chess_move = board.parse_san(move.strip())
            if chess_move in board.legal_moves:
                return board.san(chess_move), True
        except (chess.IllegalMoveError, chess.InvalidMoveError, ValueError):
            pass
        
        # Try to parse as UCI (e2e4, g1f3, etc.)
        try:
            chess_move = chess.Move.from_uci(move.strip())
            if chess_move in board.legal_moves:
                return board.san(chess_move), True
        except (chess.IllegalMoveError, chess.InvalidMoveError, ValueError):
            pass
            
        # If we can't parse it but it looks like a move, return as-is with warning
        return move.strip(), False
        
    except Exception as e:
        print(f"Error normalizing move '{move}' for position '{fen}': {e}")
        return move.strip() if move else "", False


def convert_to_san(move: str, fen: str) -> Optional[str]:
    """Convert move to Standard Algebraic Notation"""
    try:
        board = chess.Board(fen)
        
        # If already SAN, validate and return
        try:
            chess_move = board.parse_san(move)
            return board.san(chess_move)
        except:
            pass
            
        # Try UCI conversion
        try:
            chess_move = chess.Move.from_uci(move)
            return board.san(chess_move)
        except:
            pass
            
    except Exception:
        pass
        
    return None


def convert_to_uci(move: str, fen: str) -> Optional[str]:
    """Convert move to UCI notation"""
    try:
        board = chess.Board(fen)
        
        # Try SAN parsing first
        try:
            chess_move = board.parse_san(move)
            return chess_move.uci()
        except:
            pass
            
        # Try UCI validation
        try:
            chess_move = chess.Move.from_uci(move)
            if chess_move in board.legal_moves:
                return chess_move.uci()
        except:
            pass
            
    except Exception:
        pass
        
    return None


def calculate_confidence(engine_name: str, move_valid: bool, raw_response: Dict[str, Any]) -> float:
    """Calculate confidence score based on engine and response quality"""
    base_confidence = {
        "stockfish": 0.95,
        "nanogpt": 0.75,
        "gpt": 0.85,
        "claude": 0.85,
        "mistral": 0.80,
        "llama": 0.70
    }
    
    # Get base confidence for engine type
    confidence = 0.5  # default
    for engine_type, score in base_confidence.items():
        if engine_type in engine_name.lower():
            confidence = score
            break
    
    # Reduce confidence if move is invalid
    if not move_valid:
        confidence *= 0.3
    
    # Boost confidence if response includes detailed thoughts
    thoughts = extract_thoughts_from_response(raw_response)
    if thoughts and len(thoughts) > 20:
        confidence = min(confidence * 1.1, 1.0)
    
    return round(confidence, 2)


def create_error_response(
    error_message: str, 
    engine_name: str, 
    fen: str,
    raw_response: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Create standardized error response"""
    return standardize_move_response(
        raw_response=raw_response or {},
        engine_name=engine_name,
        fen=fen,
        success=False,
        error_message=error_message
    ) 